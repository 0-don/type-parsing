/**
 * Generated by orval v7.16.0 ðŸº
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */

import { customFetch } from "./api/fetch";

export type MeDtoRolesItem =
  (typeof MeDtoRolesItem)[keyof typeof MeDtoRolesItem];

export const MeDtoRolesItem = {
  ADMIN: "ADMIN",
  MOD: "MOD",
  USER: "USER",
} as const;

export interface MeDto {
  id?: string;
  email?: string;
  isPasswordSet?: boolean;
  roles?: MeDtoRolesItem[];
}

export type AssetPayoutRequestAssetSymbol =
  (typeof AssetPayoutRequestAssetSymbol)[keyof typeof AssetPayoutRequestAssetSymbol];

export const AssetPayoutRequestAssetSymbol = {
  USDT: "USDT",
  USDC: "USDC",
  BTC: "BTC",
  ETH: "ETH",
  BNB: "BNB",
  MX: "MX",
  BGB: "BGB",
  OTHER: "OTHER",
} as const;

export interface AssetPayoutRequest {
  assetSymbol: AssetPayoutRequestAssetSymbol;
  /**
   * @minLength 10
   * @maxLength 200
   */
  walletAddress: string;
  /** @minimum 1e-8 */
  amount: number;
}

export type LinkAccountRequestExchangeType =
  (typeof LinkAccountRequestExchangeType)[keyof typeof LinkAccountRequestExchangeType];

export const LinkAccountRequestExchangeType = {
  MEXC: "MEXC",
  BYBIT: "BYBIT",
  PHEMEX: "PHEMEX",
  BITGET: "BITGET",
  OKX: "OKX",
  BITUNIX: "BITUNIX",
  BINANCE: "BINANCE",
  BITMART: "BITMART",
  LEVEX: "LEVEX",
} as const;

export interface LinkAccountRequest {
  uid: string;
  exchangeType: LinkAccountRequestExchangeType;
  notifyAdmin?: boolean;
}

export type KycResetRequestExchangeType =
  (typeof KycResetRequestExchangeType)[keyof typeof KycResetRequestExchangeType];

export const KycResetRequestExchangeType = {
  MEXC: "MEXC",
  BYBIT: "BYBIT",
  PHEMEX: "PHEMEX",
  BITGET: "BITGET",
  OKX: "OKX",
  BITUNIX: "BITUNIX",
  BINANCE: "BINANCE",
  BITMART: "BITMART",
  LEVEX: "LEVEX",
} as const;

export interface KycResetRequest {
  oldUid: string;
  newUid: string;
  exchangeType: KycResetRequestExchangeType;
  notes?: string;
}

export interface EmailOtpProps {
  /** @pattern \d{6} */
  otp: string;
}

export interface ForgotPasswordProps {
  email: string;
  resetToken: string;
}

export type KycResetPropsExchangeType =
  (typeof KycResetPropsExchangeType)[keyof typeof KycResetPropsExchangeType];

export const KycResetPropsExchangeType = {
  MEXC: "MEXC",
  BYBIT: "BYBIT",
  PHEMEX: "PHEMEX",
  BITGET: "BITGET",
  OKX: "OKX",
  BITUNIX: "BITUNIX",
  BINANCE: "BINANCE",
  BITMART: "BITMART",
  LEVEX: "LEVEX",
} as const;

export interface KycResetProps {
  userEmail: string;
  oldUid?: string;
  newUid: string;
  exchangeType: KycResetPropsExchangeType;
  notes?: string;
}

export interface PayoutRequestProps {
  userEmail: string;
  userId: string;
  assetPayouts: AssetPayoutRequest[];
}

export type RedeemBenefitRequestParameters = {
  [key: string]: { [key: string]: unknown };
};

export interface RedeemBenefitRequest {
  parameters?: RedeemBenefitRequestParameters;
  notes?: string;
}

export interface UserBenefitDto {
  id?: number;
  userId: string;
  benefitId: number;
  redeemedAt?: string;
  amountReceived?: number;
}

export interface OtpVerify {
  /**
   * @minLength 5
   * @maxLength 100
   */
  email: string;
  /** @pattern \d{6} */
  otp: string;
}

export interface ResetPassword {
  resetToken: string;
  /**
   * @minLength 5
   * @maxLength 100
   */
  email: string;
  /**
   * @minLength 6
   * @maxLength 128
   */
  password: string;
}

export interface OtpResend {
  /**
   * @minLength 5
   * @maxLength 100
   */
  email: string;
}

export interface AuthRequest {
  /**
   * @minLength 5
   * @maxLength 100
   */
  email: string;
  /**
   * @minLength 6
   * @maxLength 128
   */
  password: string;
}

export interface EmailOnlyRegisterRequest {
  /**
   * @minLength 5
   * @maxLength 100
   */
  email: string;
}

export interface ForgotPassword {
  /**
   * @minLength 5
   * @maxLength 100
   */
  email: string;
}

export interface ChangePasswordRequest {
  /**
   * @minLength 6
   * @maxLength 128
   */
  currentPassword?: string;
  /**
   * @minLength 6
   * @maxLength 128
   */
  newPassword: string;
}

export type VolumeMetricsProjectionSymbol =
  (typeof VolumeMetricsProjectionSymbol)[keyof typeof VolumeMetricsProjectionSymbol];

export const VolumeMetricsProjectionSymbol = {
  USDT: "USDT",
  USDC: "USDC",
  BTC: "BTC",
  ETH: "ETH",
  BNB: "BNB",
  MX: "MX",
  BGB: "BGB",
  OTHER: "OTHER",
} as const;

export interface VolumeMetricsProjection {
  totalDailyVolume?: number;
  totalWeeklyVolume?: number;
  totalMonthlyVolume?: number;
  totalAllTimeVolume?: number;
  totalDailyReclaim?: number;
  totalWeeklyReclaim?: number;
  totalMonthlyReclaim?: number;
  totalAllTimeReclaim?: number;
  totalDailyReclaimUser?: number;
  totalWeeklyReclaimUser?: number;
  totalMonthlyReclaimUser?: number;
  totalAllTimeReclaimUser?: number;
  accountCount?: number;
  symbol?: VolumeMetricsProjectionSymbol;
}

export type AssetDtoSymbol =
  (typeof AssetDtoSymbol)[keyof typeof AssetDtoSymbol];

export const AssetDtoSymbol = {
  USDT: "USDT",
  USDC: "USDC",
  BTC: "BTC",
  ETH: "ETH",
  BNB: "BNB",
  MX: "MX",
  BGB: "BGB",
  OTHER: "OTHER",
} as const;

export interface AssetDto {
  id?: number;
  symbol: AssetDtoSymbol;
  name: string;
  decimalPlaces: number;
  minWithdrawalAmount?: number;
  isActive?: boolean;
  displayOrder?: number;
  createdAt?: string;
  updatedAt?: string;
}

export interface PageUserPayoutDto {
  totalPages?: number;
  totalElements?: number;
  pageable?: PageableObject;
  size?: number;
  content?: UserPayoutDto[];
  number?: number;
  sort?: SortObject;
  first?: boolean;
  last?: boolean;
  numberOfElements?: number;
  empty?: boolean;
}

export interface PageableObject {
  paged?: boolean;
  pageNumber?: number;
  pageSize?: number;
  unpaged?: boolean;
  offset?: number;
  sort?: SortObject;
}

export interface SortObject {
  sorted?: boolean;
  unsorted?: boolean;
  empty?: boolean;
}

export type UserPayoutDtoStatus =
  (typeof UserPayoutDtoStatus)[keyof typeof UserPayoutDtoStatus];

export const UserPayoutDtoStatus = {
  PENDING: "PENDING",
  PROCESSING: "PROCESSING",
  COMPLETED: "COMPLETED",
  FAILED: "FAILED",
  CANCELLED: "CANCELLED",
} as const;

export interface UserPayoutDto {
  id?: number;
  userId: string;
  asset: AssetDto;
  amount: number;
  walletAddress: string;
  status: UserPayoutDtoStatus;
  transactionHash?: string;
  failureReason?: string;
  completedAt?: string;
  createdAt?: string;
  updatedAt?: string;
}

export type WalletBalanceDtoAssetSymbol =
  (typeof WalletBalanceDtoAssetSymbol)[keyof typeof WalletBalanceDtoAssetSymbol];

export const WalletBalanceDtoAssetSymbol = {
  USDT: "USDT",
  USDC: "USDC",
  BTC: "BTC",
  ETH: "ETH",
  BNB: "BNB",
  MX: "MX",
  BGB: "BGB",
  OTHER: "OTHER",
} as const;

export interface WalletBalanceDto {
  assetSymbol: WalletBalanceDtoAssetSymbol;
  assetName: string;
  currentBalance: number;
  minWithdrawalAmount: number;
  isActive: boolean;
  hasMinimumAmount: boolean;
  hasPendingPayout: boolean;
  isValidForPayout: boolean;
}

export type UserBalanceDtoAssetSymbol =
  (typeof UserBalanceDtoAssetSymbol)[keyof typeof UserBalanceDtoAssetSymbol];

export const UserBalanceDtoAssetSymbol = {
  USDT: "USDT",
  USDC: "USDC",
  BTC: "BTC",
  ETH: "ETH",
  BNB: "BNB",
  MX: "MX",
  BGB: "BGB",
  OTHER: "OTHER",
} as const;

export interface UserBalanceDto {
  assetSymbol?: UserBalanceDtoAssetSymbol;
  assetName?: string;
  totalEarned?: number;
  totalPaidOut?: number;
  currentBalance?: number;
}

export interface ExchangeAccountDto {
  id?: number;
  exchange: ExchangeDto;
  userId?: string;
  uid: string;
  displayName: string;
  linkedAt?: string;
  lastSyncAt?: string;
  createdAt?: string;
  volumeMetrics?: VolumeMetricsDto[];
  userPayouts?: UserPayoutDto[];
}

export type ExchangeDtoExchangeType =
  (typeof ExchangeDtoExchangeType)[keyof typeof ExchangeDtoExchangeType];

export const ExchangeDtoExchangeType = {
  MEXC: "MEXC",
  BYBIT: "BYBIT",
  PHEMEX: "PHEMEX",
  BITGET: "BITGET",
  OKX: "OKX",
  BITUNIX: "BITUNIX",
  BINANCE: "BINANCE",
  BITMART: "BITMART",
  LEVEX: "LEVEX",
} as const;

export type ExchangeDtoTagsItem =
  (typeof ExchangeDtoTagsItem)[keyof typeof ExchangeDtoTagsItem];

export const ExchangeDtoTagsItem = {
  BEST: "BEST",
  NEW: "NEW",
  VIP: "VIP",
  CASHBACK_BOOST: "CASHBACK_BOOST",
  COMPETITION: "COMPETITION",
  HOT: "HOT",
} as const;

export interface ExchangeDto {
  id?: number;
  exchangeType: ExchangeDtoExchangeType;
  position: number;
  score?: number;
  kycRequired?: boolean;
  referralUrl: string;
  reclaimPercentage: number;
  isActive?: boolean;
  tags?: ExchangeDtoTagsItem[];
  rateConfigurations?: RateConfigurationDto[];
  specialPrograms?: SpecialProgramDto[];
}

export interface PageTradeDto {
  totalPages?: number;
  totalElements?: number;
  pageable?: PageableObject;
  size?: number;
  content?: TradeDto[];
  number?: number;
  sort?: SortObject;
  first?: boolean;
  last?: boolean;
  numberOfElements?: number;
  empty?: boolean;
}

export interface RateConfigurationDto {
  id?: number;
  exchange: ExchangeDto;
  levelNumber: number;
  levelName: string;
  makerFeeRate: number;
  takerFeeRate: number;
  minVolume?: number;
  minBalance?: number;
  minCoinBalance?: number;
  coinBalanceSymbol?: string;
}

export type SpecialProgramDtoProgramType =
  (typeof SpecialProgramDtoProgramType)[keyof typeof SpecialProgramDtoProgramType];

export const SpecialProgramDtoProgramType = {
  SIGNUP_BONUS: "SIGNUP_BONUS",
  DEPOSIT_BONUS: "DEPOSIT_BONUS",
  VOLUME_BONUS: "VOLUME_BONUS",
  CASHBACK_BOOST: "CASHBACK_BOOST",
  VIP_FAST_TRACK: "VIP_FAST_TRACK",
  TRADING_COMPETITION: "TRADING_COMPETITION",
} as const;

export type SpecialProgramDtoProgramName =
  (typeof SpecialProgramDtoProgramName)[keyof typeof SpecialProgramDtoProgramName];

export const SpecialProgramDtoProgramName = {
  WELCOME_BONUS: "WELCOME_BONUS",
  DEPOSIT_BONUS: "DEPOSIT_BONUS",
  FIRST_DEPOSIT_MATCH_10PCT: "FIRST_DEPOSIT_MATCH_10PCT",
  FIRST_DEPOSIT_MATCH_20PCT: "FIRST_DEPOSIT_MATCH_20PCT",
  VOLUME_BOOST_30_DAYS: "VOLUME_BOOST_30_DAYS",
  CASHBACK_BOOST_25PCT: "CASHBACK_BOOST_25PCT",
  VIP_TIER_UPGRADE: "VIP_TIER_UPGRADE",
} as const;

export interface SpecialProgramDto {
  id?: number;
  exchange: ExchangeDto;
  programType: SpecialProgramDtoProgramType;
  programName: SpecialProgramDtoProgramName;
  bonusAmount?: number;
  bonusCurrency?: string;
  newUsersOnly?: boolean;
  minDepositAmount?: number;
  minTradingVolume?: number;
  requiresKyc?: boolean;
  durationDays?: number;
  isActive?: boolean;
  startDate?: string;
  endDate?: string;
  displayOrder?: number;
  createdAt?: string;
  updatedAt?: string;
}

export type TradeDtoTradeType =
  (typeof TradeDtoTradeType)[keyof typeof TradeDtoTradeType];

export const TradeDtoTradeType = {
  SPOT: "SPOT",
  FUTURES: "FUTURES",
  OPTIONS: "OPTIONS",
  SWAP: "SWAP",
  MARGIN: "MARGIN",
  OPTION: "OPTION",
} as const;

export interface TradeDto {
  id?: number;
  account: ExchangeAccountDto;
  tradeId?: string;
  symbol?: string;
  asset: AssetDto;
  tradeType: TradeDtoTradeType;
  amount: number;
  reclaim?: number;
  reclaimUser?: number;
  tradeTime: string;
}

export interface VolumeMetricsDto {
  id?: number;
  exchangeAccount?: ExchangeAccountDto;
  exchangeAccountId: number;
  asset: AssetDto;
  dailyVolume?: number;
  weeklyVolume?: number;
  monthlyVolume?: number;
  allTimeVolume?: number;
  dailyReclaim?: number;
  weeklyReclaim?: number;
  monthlyReclaim?: number;
  allTimeReclaim?: number;
  dailyReclaimUser?: number;
  weeklyReclaimUser?: number;
  monthlyReclaimUser?: number;
  allTimeReclaimUser?: number;
  updatedAt?: string;
}

export interface ReclaimActivity {
  date?: string;
  count?: number;
  totalReclaim?: number;
}

export interface MonthlyAverageReclaim {
  month?: string;
  averageReclaimAmount?: number;
}

export interface PageExchangeDto {
  totalPages?: number;
  totalElements?: number;
  pageable?: PageableObject;
  size?: number;
  content?: ExchangeDto[];
  number?: number;
  sort?: SortObject;
  first?: boolean;
  last?: boolean;
  numberOfElements?: number;
  empty?: boolean;
}

export interface UserReclaimRankingDto {
  rank?: number;
  displayName?: string;
  totalReclaim?: number;
  totalTrades?: number;
  lastTradeTime?: string;
}

export type ExchangeReclaimDtoExchangeType =
  (typeof ExchangeReclaimDtoExchangeType)[keyof typeof ExchangeReclaimDtoExchangeType];

export const ExchangeReclaimDtoExchangeType = {
  MEXC: "MEXC",
  BYBIT: "BYBIT",
  PHEMEX: "PHEMEX",
  BITGET: "BITGET",
  OKX: "OKX",
  BITUNIX: "BITUNIX",
  BINANCE: "BINANCE",
  BITMART: "BITMART",
  LEVEX: "LEVEX",
} as const;

export interface ExchangeReclaimDto {
  id?: number;
  exchangeType?: ExchangeReclaimDtoExchangeType;
  name?: string;
  displayName?: string;
  logoUrl?: string;
  totalReclaim?: number;
  totalTrades?: number;
  totalAccounts?: number;
}

export interface PageExchangeAccountDto {
  totalPages?: number;
  totalElements?: number;
  pageable?: PageableObject;
  size?: number;
  content?: ExchangeAccountDto[];
  number?: number;
  sort?: SortObject;
  first?: boolean;
  last?: boolean;
  numberOfElements?: number;
  empty?: boolean;
}

export type EventDtoEventType =
  (typeof EventDtoEventType)[keyof typeof EventDtoEventType];

export const EventDtoEventType = {
  TRADING_COMPETITION: "TRADING_COMPETITION",
  CASHBACK_BOOST: "CASHBACK_BOOST",
  SPECIAL_PROMOTION: "SPECIAL_PROMOTION",
  EXTERNAL_EVENT: "EXTERNAL_EVENT",
} as const;

export type EventDtoStatus =
  (typeof EventDtoStatus)[keyof typeof EventDtoStatus];

export const EventDtoStatus = {
  ACTIVE: "ACTIVE",
  SCHEDULED: "SCHEDULED",
  ENDED: "ENDED",
} as const;

export type EventDtoExchangeType =
  (typeof EventDtoExchangeType)[keyof typeof EventDtoExchangeType];

export const EventDtoExchangeType = {
  MEXC: "MEXC",
  BYBIT: "BYBIT",
  PHEMEX: "PHEMEX",
  BITGET: "BITGET",
  OKX: "OKX",
  BITUNIX: "BITUNIX",
  BINANCE: "BINANCE",
  BITMART: "BITMART",
  LEVEX: "LEVEX",
} as const;

export interface EventDto {
  id?: number;
  title: string;
  description?: string;
  eventType: EventDtoEventType;
  status: EventDtoStatus;
  startDate: string;
  endDate: string;
  bannerImageUrl?: string;
  prizePool?: string;
  externalUrl?: string;
  exchangeType?: EventDtoExchangeType;
  featured?: boolean;
  displayOrder?: number;
  createdAt?: string;
  updatedAt?: string;
}

export interface PageEventDto {
  totalPages?: number;
  totalElements?: number;
  pageable?: PageableObject;
  size?: number;
  content?: EventDto[];
  number?: number;
  sort?: SortObject;
  first?: boolean;
  last?: boolean;
  numberOfElements?: number;
  empty?: boolean;
}

export type BenefitDtoBenefitType =
  (typeof BenefitDtoBenefitType)[keyof typeof BenefitDtoBenefitType];

export const BenefitDtoBenefitType = {
  SPECIAL: "SPECIAL",
  TRADE_RECLAIM: "TRADE_RECLAIM",
} as const;

export type BenefitDtoBenefitEnum =
  (typeof BenefitDtoBenefitEnum)[keyof typeof BenefitDtoBenefitEnum];

export const BenefitDtoBenefitEnum = {
  DAILY_BTC_PRIZE_DRAW: "DAILY_BTC_PRIZE_DRAW",
  FIRST_CASHBACK_CLAIM: "FIRST_CASHBACK_CLAIM",
  EVENT_PARTICIPATION_BONUS: "EVENT_PARTICIPATION_BONUS",
  MONTHLY_CASHBACK_CLAIM: "MONTHLY_CASHBACK_CLAIM",
  FRIEND_INVITATION_BONUS: "FRIEND_INVITATION_BONUS",
  TRADE_RECLAIM_CASHBACK_BOOST: "TRADE_RECLAIM_CASHBACK_BOOST",
  BITCOIN_PRICE_PREDICTION: "BITCOIN_PRICE_PREDICTION",
  EXTRA_CASHBACK_REWARD: "EXTRA_CASHBACK_REWARD",
  REFER_FRIEND_BONUS: "REFER_FRIEND_BONUS",
  FIRST_VISIT_BONUS: "FIRST_VISIT_BONUS",
  ALARM_NOTIFICATION_REWARD: "ALARM_NOTIFICATION_REWARD",
  ESTIMATED_CASHBACK_REWARD: "ESTIMATED_CASHBACK_REWARD",
  UID_BINDING_BONUS: "UID_BINDING_BONUS",
} as const;

export type BenefitDtoRequirements = {
  [key: string]: { [key: string]: unknown };
};

export interface BenefitDto {
  id?: number;
  benefitType: BenefitDtoBenefitType;
  benefitEnum: BenefitDtoBenefitEnum;
  rewardAmount?: number;
  rewardCurrency?: string;
  isActive?: boolean;
  isRepeatable?: boolean;
  maxRedemptions?: number;
  validFrom?: string;
  validUntil?: string;
  requirements?: BenefitDtoRequirements;
  sortOrder?: number;
  comingSoon?: boolean;
  url?: string;
}

export type MailParams = {
  emailType: MailEmailType;
  emailOTP: EmailOtpProps;
  resetPassword: ForgotPasswordProps;
  kycResetProps: KycResetProps;
  payoutRequestProps: PayoutRequestProps;
};

export type MailEmailType = (typeof MailEmailType)[keyof typeof MailEmailType];

export const MailEmailType = {
  OTP: "OTP",
  FORGOT_PASSWORD: "FORGOT_PASSWORD",
  KYC_RESET: "KYC_RESET",
  PAYOUT_REQUEST: "PAYOUT_REQUEST",
} as const;

export type ChangePassword200 = { [key: string]: string };

export type GetVolumeMetricsParams = {
  symbolType?: GetVolumeMetricsSymbolType;
};

export type GetVolumeMetricsSymbolType =
  (typeof GetVolumeMetricsSymbolType)[keyof typeof GetVolumeMetricsSymbolType];

export const GetVolumeMetricsSymbolType = {
  USDT: "USDT",
  USDC: "USDC",
  BTC: "BTC",
  ETH: "ETH",
  BNB: "BNB",
  MX: "MX",
  BGB: "BGB",
  OTHER: "OTHER",
} as const;

export type GetUserPayoutsParams = {
  status?: GetUserPayoutsStatusItem[];
  assetSymbol?: GetUserPayoutsAssetSymbolItem[];
  globalFilter?: string;
  /**
   * Zero-based page index (0..N)
   * @minimum 0
   */
  page?: number;
  /**
   * The size of the page to be returned
   * @minimum 1
   */
  size?: number;
  /**
   * Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   */
  sort?: string[];
};

export type GetUserPayoutsStatusItem =
  (typeof GetUserPayoutsStatusItem)[keyof typeof GetUserPayoutsStatusItem];

export const GetUserPayoutsStatusItem = {
  PENDING: "PENDING",
  PROCESSING: "PROCESSING",
  COMPLETED: "COMPLETED",
  FAILED: "FAILED",
  CANCELLED: "CANCELLED",
} as const;

export type GetUserPayoutsAssetSymbolItem =
  (typeof GetUserPayoutsAssetSymbolItem)[keyof typeof GetUserPayoutsAssetSymbolItem];

export const GetUserPayoutsAssetSymbolItem = {
  USDT: "USDT",
  USDC: "USDC",
  BTC: "BTC",
  ETH: "ETH",
  BNB: "BNB",
  MX: "MX",
  BGB: "BGB",
  OTHER: "OTHER",
} as const;

export type GetTradesParams = {
  exchangeType?: GetTradesExchangeType;
  uid?: string;
  globalFilter?: string;
  from?: string;
  to?: string;
  /**
   * Zero-based page index (0..N)
   * @minimum 0
   */
  page?: number;
  /**
   * The size of the page to be returned
   * @minimum 1
   */
  size?: number;
  /**
   * Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   */
  sort?: string[];
};

export type GetTradesExchangeType =
  (typeof GetTradesExchangeType)[keyof typeof GetTradesExchangeType];

export const GetTradesExchangeType = {
  MEXC: "MEXC",
  BYBIT: "BYBIT",
  PHEMEX: "PHEMEX",
  BITGET: "BITGET",
  OKX: "OKX",
  BITUNIX: "BITUNIX",
  BINANCE: "BINANCE",
  BITMART: "BITMART",
  LEVEX: "LEVEX",
} as const;

export type GetTradeOverviewParams = {
  exchangeType?: GetTradeOverviewExchangeType;
  uid?: string;
  from?: string;
  to?: string;
};

export type GetTradeOverviewExchangeType =
  (typeof GetTradeOverviewExchangeType)[keyof typeof GetTradeOverviewExchangeType];

export const GetTradeOverviewExchangeType = {
  MEXC: "MEXC",
  BYBIT: "BYBIT",
  PHEMEX: "PHEMEX",
  BITGET: "BITGET",
  OKX: "OKX",
  BITUNIX: "BITUNIX",
  BINANCE: "BINANCE",
  BITMART: "BITMART",
  LEVEX: "LEVEX",
} as const;

export type GetTradesMonthlyAverageReclaimParams = {
  exchangeType: GetTradesMonthlyAverageReclaimExchangeType;
};

export type GetTradesMonthlyAverageReclaimExchangeType =
  (typeof GetTradesMonthlyAverageReclaimExchangeType)[keyof typeof GetTradesMonthlyAverageReclaimExchangeType];

export const GetTradesMonthlyAverageReclaimExchangeType = {
  MEXC: "MEXC",
  BYBIT: "BYBIT",
  PHEMEX: "PHEMEX",
  BITGET: "BITGET",
  OKX: "OKX",
  BITUNIX: "BITUNIX",
  BINANCE: "BINANCE",
  BITMART: "BITMART",
  LEVEX: "LEVEX",
} as const;

export type GetExchangesParams = {
  /**
   * Zero-based page index (0..N)
   * @minimum 0
   */
  page?: number;
  /**
   * The size of the page to be returned
   * @minimum 1
   */
  size?: number;
  /**
   * Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   */
  sort?: string[];
};

export type GetUserExchangeReclaimRankingParams = {
  exchangeType: GetUserExchangeReclaimRankingExchangeType;
  topN?: number;
};

export type GetUserExchangeReclaimRankingExchangeType =
  (typeof GetUserExchangeReclaimRankingExchangeType)[keyof typeof GetUserExchangeReclaimRankingExchangeType];

export const GetUserExchangeReclaimRankingExchangeType = {
  MEXC: "MEXC",
  BYBIT: "BYBIT",
  PHEMEX: "PHEMEX",
  BITGET: "BITGET",
  OKX: "OKX",
  BITUNIX: "BITUNIX",
  BINANCE: "BINANCE",
  BITMART: "BITMART",
  LEVEX: "LEVEX",
} as const;

export type GetExchangeAccountsParams = {
  exchangeType?: GetExchangeAccountsExchangeType;
  uid?: string;
  globalFilter?: string;
  /**
   * Zero-based page index (0..N)
   * @minimum 0
   */
  page?: number;
  /**
   * The size of the page to be returned
   * @minimum 1
   */
  size?: number;
  /**
   * Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   */
  sort?: string[];
};

export type GetExchangeAccountsExchangeType =
  (typeof GetExchangeAccountsExchangeType)[keyof typeof GetExchangeAccountsExchangeType];

export const GetExchangeAccountsExchangeType = {
  MEXC: "MEXC",
  BYBIT: "BYBIT",
  PHEMEX: "PHEMEX",
  BITGET: "BITGET",
  OKX: "OKX",
  BITUNIX: "BITUNIX",
  BINANCE: "BINANCE",
  BITMART: "BITMART",
  LEVEX: "LEVEX",
} as const;

export type GetExchangeAccountsCountByTypeParams = {
  exchangeType: GetExchangeAccountsCountByTypeExchangeType;
};

export type GetExchangeAccountsCountByTypeExchangeType =
  (typeof GetExchangeAccountsCountByTypeExchangeType)[keyof typeof GetExchangeAccountsCountByTypeExchangeType];

export const GetExchangeAccountsCountByTypeExchangeType = {
  MEXC: "MEXC",
  BYBIT: "BYBIT",
  PHEMEX: "PHEMEX",
  BITGET: "BITGET",
  OKX: "OKX",
  BITUNIX: "BITUNIX",
  BINANCE: "BINANCE",
  BITMART: "BITMART",
  LEVEX: "LEVEX",
} as const;

export type GetAllEventsParams = {
  status?: GetAllEventsStatusItem[];
  exchangeType?: GetAllEventsExchangeType;
  featured?: boolean;
  /**
   * Zero-based page index (0..N)
   * @minimum 0
   */
  page?: number;
  /**
   * The size of the page to be returned
   * @minimum 1
   */
  size?: number;
  /**
   * Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   */
  sort?: string[];
};

export type GetAllEventsStatusItem =
  (typeof GetAllEventsStatusItem)[keyof typeof GetAllEventsStatusItem];

export const GetAllEventsStatusItem = {
  ACTIVE: "ACTIVE",
  SCHEDULED: "SCHEDULED",
  ENDED: "ENDED",
} as const;

export type GetAllEventsExchangeType =
  (typeof GetAllEventsExchangeType)[keyof typeof GetAllEventsExchangeType];

export const GetAllEventsExchangeType = {
  MEXC: "MEXC",
  BYBIT: "BYBIT",
  PHEMEX: "PHEMEX",
  BITGET: "BITGET",
  OKX: "OKX",
  BITUNIX: "BITUNIX",
  BINANCE: "BINANCE",
  BITMART: "BITMART",
  LEVEX: "LEVEX",
} as const;

export type GetFeaturedEventsParams = {
  exchangeType?: GetFeaturedEventsExchangeType;
};

export type GetFeaturedEventsExchangeType =
  (typeof GetFeaturedEventsExchangeType)[keyof typeof GetFeaturedEventsExchangeType];

export const GetFeaturedEventsExchangeType = {
  MEXC: "MEXC",
  BYBIT: "BYBIT",
  PHEMEX: "PHEMEX",
  BITGET: "BITGET",
  OKX: "OKX",
  BITUNIX: "BITUNIX",
  BINANCE: "BINANCE",
  BITMART: "BITMART",
  LEVEX: "LEVEX",
} as const;

export type GetActiveEventsParams = {
  exchangeType?: GetActiveEventsExchangeType;
};

export type GetActiveEventsExchangeType =
  (typeof GetActiveEventsExchangeType)[keyof typeof GetActiveEventsExchangeType];

export const GetActiveEventsExchangeType = {
  MEXC: "MEXC",
  BYBIT: "BYBIT",
  PHEMEX: "PHEMEX",
  BITGET: "BITGET",
  OKX: "OKX",
  BITUNIX: "BITUNIX",
  BINANCE: "BINANCE",
  BITMART: "BITMART",
  LEVEX: "LEVEX",
} as const;

export type GetAllBenefitsParams = {
  benefitType?: GetAllBenefitsBenefitType;
};

export type GetAllBenefitsBenefitType =
  (typeof GetAllBenefitsBenefitType)[keyof typeof GetAllBenefitsBenefitType];

export const GetAllBenefitsBenefitType = {
  SPECIAL: "SPECIAL",
  TRADE_RECLAIM: "TRADE_RECLAIM",
} as const;

export type getMeResponse200 = {
  data: MeDto;
  status: 200;
};

export type getMeResponseSuccess = getMeResponse200 & {
  headers: Headers;
};
export type getMeResponse = getMeResponseSuccess;

export const getGetMeUrl = () => {
  return `/api/user/me`;
};

export const getMe = async (options?: RequestInit): Promise<getMeResponse> => {
  return customFetch<getMeResponse>(getGetMeUrl(), {
    ...options,
    method: "POST",
  });
};

export type requestPayoutResponse200 = {
  data: void;
  status: 200;
};

export type requestPayoutResponseSuccess = requestPayoutResponse200 & {
  headers: Headers;
};
export type requestPayoutResponse = requestPayoutResponseSuccess;

export const getRequestPayoutUrl = () => {
  return `/api/user-payout/request-payout`;
};

export const requestPayout = async (
  assetPayoutRequest: AssetPayoutRequest[],
  options?: RequestInit
): Promise<requestPayoutResponse> => {
  return customFetch<requestPayoutResponse>(getRequestPayoutUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(assetPayoutRequest),
  });
};

export type linkExchangeAccountResponse200 = {
  data: void;
  status: 200;
};

export type linkExchangeAccountResponseSuccess =
  linkExchangeAccountResponse200 & {
    headers: Headers;
  };
export type linkExchangeAccountResponse = linkExchangeAccountResponseSuccess;

export const getLinkExchangeAccountUrl = () => {
  return `/api/exchange-account/link`;
};

export const linkExchangeAccount = async (
  linkAccountRequest: LinkAccountRequest,
  options?: RequestInit
): Promise<linkExchangeAccountResponse> => {
  return customFetch<linkExchangeAccountResponse>(getLinkExchangeAccountUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(linkAccountRequest),
  });
};

export type requestKycResetResponse200 = {
  data: void;
  status: 200;
};

export type requestKycResetResponseSuccess = requestKycResetResponse200 & {
  headers: Headers;
};
export type requestKycResetResponse = requestKycResetResponseSuccess;

export const getRequestKycResetUrl = () => {
  return `/api/exchange-account/kyc-reset`;
};

export const requestKycReset = async (
  kycResetRequest: KycResetRequest,
  options?: RequestInit
): Promise<requestKycResetResponse> => {
  return customFetch<requestKycResetResponse>(getRequestKycResetUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(kycResetRequest),
  });
};

export type mailResponse200 = {
  data: void;
  status: 200;
};

export type mailResponseSuccess = mailResponse200 & {
  headers: Headers;
};
export type mailResponse = mailResponseSuccess;

export const getMailUrl = (params: MailParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/email?${stringifiedParams}`
    : `/api/email`;
};

export const mail = async (
  params: MailParams,
  options?: RequestInit
): Promise<mailResponse> => {
  return customFetch<mailResponse>(getMailUrl(params), {
    ...options,
    method: "POST",
  });
};

export type redeemBenefitResponse200 = {
  data: UserBenefitDto;
  status: 200;
};

export type redeemBenefitResponseSuccess = redeemBenefitResponse200 & {
  headers: Headers;
};
export type redeemBenefitResponse = redeemBenefitResponseSuccess;

export const getRedeemBenefitUrl = (benefitId: number) => {
  return `/api/benefits/${benefitId}/redeem`;
};

export const redeemBenefit = async (
  benefitId: number,
  redeemBenefitRequest: RedeemBenefitRequest,
  options?: RequestInit
): Promise<redeemBenefitResponse> => {
  return customFetch<redeemBenefitResponse>(getRedeemBenefitUrl(benefitId), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(redeemBenefitRequest),
  });
};

export type verifyOtpResponse200 = {
  data: void;
  status: 200;
};

export type verifyOtpResponseSuccess = verifyOtpResponse200 & {
  headers: Headers;
};
export type verifyOtpResponse = verifyOtpResponseSuccess;

export const getVerifyOtpUrl = () => {
  return `/api/auth/verify-otp`;
};

export const verifyOtp = async (
  otpVerify: OtpVerify,
  options?: RequestInit
): Promise<verifyOtpResponse> => {
  return customFetch<verifyOtpResponse>(getVerifyOtpUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(otpVerify),
  });
};

export type resetPasswordResponse200 = {
  data: void;
  status: 200;
};

export type resetPasswordResponseSuccess = resetPasswordResponse200 & {
  headers: Headers;
};
export type resetPasswordResponse = resetPasswordResponseSuccess;

export const getResetPasswordUrl = () => {
  return `/api/auth/reset-password`;
};

export const resetPassword = async (
  resetPassword: ResetPassword,
  options?: RequestInit
): Promise<resetPasswordResponse> => {
  return customFetch<resetPasswordResponse>(getResetPasswordUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(resetPassword),
  });
};

export type resendOtpResponse200 = {
  data: void;
  status: 200;
};

export type resendOtpResponseSuccess = resendOtpResponse200 & {
  headers: Headers;
};
export type resendOtpResponse = resendOtpResponseSuccess;

export const getResendOtpUrl = () => {
  return `/api/auth/resend-otp`;
};

export const resendOtp = async (
  otpResend: OtpResend,
  options?: RequestInit
): Promise<resendOtpResponse> => {
  return customFetch<resendOtpResponse>(getResendOtpUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(otpResend),
  });
};

export type registerResponse200 = {
  data: void;
  status: 200;
};

export type registerResponseSuccess = registerResponse200 & {
  headers: Headers;
};
export type registerResponse = registerResponseSuccess;

export const getRegisterUrl = () => {
  return `/api/auth/register`;
};

export const register = async (
  authRequest: AuthRequest,
  options?: RequestInit
): Promise<registerResponse> => {
  return customFetch<registerResponse>(getRegisterUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(authRequest),
  });
};

export type registerWithEmailOnlyResponse200 = {
  data: void;
  status: 200;
};

export type registerWithEmailOnlyResponseSuccess =
  registerWithEmailOnlyResponse200 & {
    headers: Headers;
  };
export type registerWithEmailOnlyResponse =
  registerWithEmailOnlyResponseSuccess;

export const getRegisterWithEmailOnlyUrl = () => {
  return `/api/auth/register-email-only`;
};

export const registerWithEmailOnly = async (
  emailOnlyRegisterRequest: EmailOnlyRegisterRequest,
  options?: RequestInit
): Promise<registerWithEmailOnlyResponse> => {
  return customFetch<registerWithEmailOnlyResponse>(
    getRegisterWithEmailOnlyUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(emailOnlyRegisterRequest),
    }
  );
};

export type logoutResponse200 = {
  data: void;
  status: 200;
};

export type logoutResponseSuccess = logoutResponse200 & {
  headers: Headers;
};
export type logoutResponse = logoutResponseSuccess;

export const getLogoutUrl = () => {
  return `/api/auth/logout`;
};

export const logout = async (
  options?: RequestInit
): Promise<logoutResponse> => {
  return customFetch<logoutResponse>(getLogoutUrl(), {
    ...options,
    method: "POST",
  });
};

export type loginResponse200 = {
  data: void;
  status: 200;
};

export type loginResponseSuccess = loginResponse200 & {
  headers: Headers;
};
export type loginResponse = loginResponseSuccess;

export const getLoginUrl = () => {
  return `/api/auth/login`;
};

export const login = async (
  authRequest: AuthRequest,
  options?: RequestInit
): Promise<loginResponse> => {
  return customFetch<loginResponse>(getLoginUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(authRequest),
  });
};

export type forgotPasswordResponse200 = {
  data: void;
  status: 200;
};

export type forgotPasswordResponseSuccess = forgotPasswordResponse200 & {
  headers: Headers;
};
export type forgotPasswordResponse = forgotPasswordResponseSuccess;

export const getForgotPasswordUrl = () => {
  return `/api/auth/forgot-password`;
};

export const forgotPassword = async (
  forgotPassword: ForgotPassword,
  options?: RequestInit
): Promise<forgotPasswordResponse> => {
  return customFetch<forgotPasswordResponse>(getForgotPasswordUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(forgotPassword),
  });
};

export type changePasswordResponse200 = {
  data: ChangePassword200;
  status: 200;
};

export type changePasswordResponseSuccess = changePasswordResponse200 & {
  headers: Headers;
};
export type changePasswordResponse = changePasswordResponseSuccess;

export const getChangePasswordUrl = () => {
  return `/api/auth/change-password`;
};

export const changePassword = async (
  changePasswordRequest: ChangePasswordRequest,
  options?: RequestInit
): Promise<changePasswordResponse> => {
  return customFetch<changePasswordResponse>(getChangePasswordUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(changePasswordRequest),
  });
};

export type getVolumeMetricsResponse200 = {
  data: VolumeMetricsProjection[];
  status: 200;
};

export type getVolumeMetricsResponseSuccess = getVolumeMetricsResponse200 & {
  headers: Headers;
};
export type getVolumeMetricsResponse = getVolumeMetricsResponseSuccess;

export const getGetVolumeMetricsUrl = (params?: GetVolumeMetricsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/volume-metrics?${stringifiedParams}`
    : `/api/volume-metrics`;
};

export const getVolumeMetrics = async (
  params?: GetVolumeMetricsParams,
  options?: RequestInit
): Promise<getVolumeMetricsResponse> => {
  return customFetch<getVolumeMetricsResponse>(getGetVolumeMetricsUrl(params), {
    ...options,
    method: "GET",
  });
};

export type getUserPayoutsResponse200 = {
  data: PageUserPayoutDto;
  status: 200;
};

export type getUserPayoutsResponseSuccess = getUserPayoutsResponse200 & {
  headers: Headers;
};
export type getUserPayoutsResponse = getUserPayoutsResponseSuccess;

export const getGetUserPayoutsUrl = (params?: GetUserPayoutsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["status", "assetSymbol", "sort"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? "null" : v.toString());
      });
      return;
    }

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/user-payout?${stringifiedParams}`
    : `/api/user-payout`;
};

export const getUserPayouts = async (
  params?: GetUserPayoutsParams,
  options?: RequestInit
): Promise<getUserPayoutsResponse> => {
  return customFetch<getUserPayoutsResponse>(getGetUserPayoutsUrl(params), {
    ...options,
    method: "GET",
  });
};

export type getWalletBalancesResponse200 = {
  data: WalletBalanceDto[];
  status: 200;
};

export type getWalletBalancesResponseSuccess = getWalletBalancesResponse200 & {
  headers: Headers;
};
export type getWalletBalancesResponse = getWalletBalancesResponseSuccess;

export const getGetWalletBalancesUrl = () => {
  return `/api/user-payout/wallet-balances`;
};

export const getWalletBalances = async (
  options?: RequestInit
): Promise<getWalletBalancesResponse> => {
  return customFetch<getWalletBalancesResponse>(getGetWalletBalancesUrl(), {
    ...options,
    method: "GET",
  });
};

export type getCurrentBalanceResponse200 = {
  data: UserBalanceDto[];
  status: 200;
};

export type getCurrentBalanceResponseSuccess = getCurrentBalanceResponse200 & {
  headers: Headers;
};
export type getCurrentBalanceResponse = getCurrentBalanceResponseSuccess;

export const getGetCurrentBalanceUrl = () => {
  return `/api/user-payout/balance`;
};

export const getCurrentBalance = async (
  options?: RequestInit
): Promise<getCurrentBalanceResponse> => {
  return customFetch<getCurrentBalanceResponse>(getGetCurrentBalanceUrl(), {
    ...options,
    method: "GET",
  });
};

export type getTradesResponse200 = {
  data: PageTradeDto;
  status: 200;
};

export type getTradesResponseSuccess = getTradesResponse200 & {
  headers: Headers;
};
export type getTradesResponse = getTradesResponseSuccess;

export const getGetTradesUrl = (params?: GetTradesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["sort"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? "null" : v.toString());
      });
      return;
    }

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/trade?${stringifiedParams}`
    : `/api/trade`;
};

export const getTrades = async (
  params?: GetTradesParams,
  options?: RequestInit
): Promise<getTradesResponse> => {
  return customFetch<getTradesResponse>(getGetTradesUrl(params), {
    ...options,
    method: "GET",
  });
};

export type getTradesReclaimAmountResponse200 = {
  data: number;
  status: 200;
};

export type getTradesReclaimAmountResponseSuccess =
  getTradesReclaimAmountResponse200 & {
    headers: Headers;
  };
export type getTradesReclaimAmountResponse =
  getTradesReclaimAmountResponseSuccess;

export const getGetTradesReclaimAmountUrl = () => {
  return `/api/trade/reclaim-amount`;
};

export const getTradesReclaimAmount = async (
  options?: RequestInit
): Promise<getTradesReclaimAmountResponse> => {
  return customFetch<getTradesReclaimAmountResponse>(
    getGetTradesReclaimAmountUrl(),
    {
      ...options,
      method: "GET",
    }
  );
};

export type getTradeOverviewResponse200 = {
  data: ReclaimActivity[];
  status: 200;
};

export type getTradeOverviewResponseSuccess = getTradeOverviewResponse200 & {
  headers: Headers;
};
export type getTradeOverviewResponse = getTradeOverviewResponseSuccess;

export const getGetTradeOverviewUrl = (params?: GetTradeOverviewParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/trade/overview?${stringifiedParams}`
    : `/api/trade/overview`;
};

export const getTradeOverview = async (
  params?: GetTradeOverviewParams,
  options?: RequestInit
): Promise<getTradeOverviewResponse> => {
  return customFetch<getTradeOverviewResponse>(getGetTradeOverviewUrl(params), {
    ...options,
    method: "GET",
  });
};

export type getTradesMonthlyAverageReclaimResponse200 = {
  data: MonthlyAverageReclaim[];
  status: 200;
};

export type getTradesMonthlyAverageReclaimResponseSuccess =
  getTradesMonthlyAverageReclaimResponse200 & {
    headers: Headers;
  };
export type getTradesMonthlyAverageReclaimResponse =
  getTradesMonthlyAverageReclaimResponseSuccess;

export const getGetTradesMonthlyAverageReclaimUrl = (
  params: GetTradesMonthlyAverageReclaimParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/trade/monthly-average-reclaim?${stringifiedParams}`
    : `/api/trade/monthly-average-reclaim`;
};

export const getTradesMonthlyAverageReclaim = async (
  params: GetTradesMonthlyAverageReclaimParams,
  options?: RequestInit
): Promise<getTradesMonthlyAverageReclaimResponse> => {
  return customFetch<getTradesMonthlyAverageReclaimResponse>(
    getGetTradesMonthlyAverageReclaimUrl(params),
    {
      ...options,
      method: "GET",
    }
  );
};

export type getExchangesResponse200 = {
  data: PageExchangeDto;
  status: 200;
};

export type getExchangesResponseSuccess = getExchangesResponse200 & {
  headers: Headers;
};
export type getExchangesResponse = getExchangesResponseSuccess;

export const getGetExchangesUrl = (params?: GetExchangesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["sort"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? "null" : v.toString());
      });
      return;
    }

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/exchange?${stringifiedParams}`
    : `/api/exchange`;
};

export const getExchanges = async (
  params?: GetExchangesParams,
  options?: RequestInit
): Promise<getExchangesResponse> => {
  return customFetch<getExchangesResponse>(getGetExchangesUrl(params), {
    ...options,
    method: "GET",
  });
};

export type getExchangeByTypeResponse200 = {
  data: ExchangeDto;
  status: 200;
};

export type getExchangeByTypeResponseSuccess = getExchangeByTypeResponse200 & {
  headers: Headers;
};
export type getExchangeByTypeResponse = getExchangeByTypeResponseSuccess;

export const getGetExchangeByTypeUrl = (
  exchangeType:
    | "MEXC"
    | "BYBIT"
    | "PHEMEX"
    | "BITGET"
    | "OKX"
    | "BITUNIX"
    | "BINANCE"
    | "BITMART"
    | "LEVEX"
) => {
  return `/api/exchange/${exchangeType}`;
};

export const getExchangeByType = async (
  exchangeType:
    | "MEXC"
    | "BYBIT"
    | "PHEMEX"
    | "BITGET"
    | "OKX"
    | "BITUNIX"
    | "BINANCE"
    | "BITMART"
    | "LEVEX",
  options?: RequestInit
): Promise<getExchangeByTypeResponse> => {
  return customFetch<getExchangeByTypeResponse>(
    getGetExchangeByTypeUrl(exchangeType),
    {
      ...options,
      method: "GET",
    }
  );
};

export type getUserExchangeReclaimRankingResponse200 = {
  data: UserReclaimRankingDto[];
  status: 200;
};

export type getUserExchangeReclaimRankingResponseSuccess =
  getUserExchangeReclaimRankingResponse200 & {
    headers: Headers;
  };
export type getUserExchangeReclaimRankingResponse =
  getUserExchangeReclaimRankingResponseSuccess;

export const getGetUserExchangeReclaimRankingUrl = (
  params: GetUserExchangeReclaimRankingParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/exchange/user-reclaim-ranking?${stringifiedParams}`
    : `/api/exchange/user-reclaim-ranking`;
};

export const getUserExchangeReclaimRanking = async (
  params: GetUserExchangeReclaimRankingParams,
  options?: RequestInit
): Promise<getUserExchangeReclaimRankingResponse> => {
  return customFetch<getUserExchangeReclaimRankingResponse>(
    getGetUserExchangeReclaimRankingUrl(params),
    {
      ...options,
      method: "GET",
    }
  );
};

export type getExchangeReclaimRankingResponse200 = {
  data: ExchangeReclaimDto[];
  status: 200;
};

export type getExchangeReclaimRankingResponseSuccess =
  getExchangeReclaimRankingResponse200 & {
    headers: Headers;
  };
export type getExchangeReclaimRankingResponse =
  getExchangeReclaimRankingResponseSuccess;

export const getGetExchangeReclaimRankingUrl = () => {
  return `/api/exchange/reclaim-ranking`;
};

export const getExchangeReclaimRanking = async (
  options?: RequestInit
): Promise<getExchangeReclaimRankingResponse> => {
  return customFetch<getExchangeReclaimRankingResponse>(
    getGetExchangeReclaimRankingUrl(),
    {
      ...options,
      method: "GET",
    }
  );
};

export type getExchangeAccountsResponse200 = {
  data: PageExchangeAccountDto;
  status: 200;
};

export type getExchangeAccountsResponseSuccess =
  getExchangeAccountsResponse200 & {
    headers: Headers;
  };
export type getExchangeAccountsResponse = getExchangeAccountsResponseSuccess;

export const getGetExchangeAccountsUrl = (
  params?: GetExchangeAccountsParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["sort"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? "null" : v.toString());
      });
      return;
    }

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/exchange-account?${stringifiedParams}`
    : `/api/exchange-account`;
};

export const getExchangeAccounts = async (
  params?: GetExchangeAccountsParams,
  options?: RequestInit
): Promise<getExchangeAccountsResponse> => {
  return customFetch<getExchangeAccountsResponse>(
    getGetExchangeAccountsUrl(params),
    {
      ...options,
      method: "GET",
    }
  );
};

export type getExchangeAccountCountResponse200 = {
  data: number;
  status: 200;
};

export type getExchangeAccountCountResponseSuccess =
  getExchangeAccountCountResponse200 & {
    headers: Headers;
  };
export type getExchangeAccountCountResponse =
  getExchangeAccountCountResponseSuccess;

export const getGetExchangeAccountCountUrl = () => {
  return `/api/exchange-account/user-count`;
};

export const getExchangeAccountCount = async (
  options?: RequestInit
): Promise<getExchangeAccountCountResponse> => {
  return customFetch<getExchangeAccountCountResponse>(
    getGetExchangeAccountCountUrl(),
    {
      ...options,
      method: "GET",
    }
  );
};

export type getUserExchangeAccountsResponse200 = {
  data: ExchangeAccountDto[];
  status: 200;
};

export type getUserExchangeAccountsResponseSuccess =
  getUserExchangeAccountsResponse200 & {
    headers: Headers;
  };
export type getUserExchangeAccountsResponse =
  getUserExchangeAccountsResponseSuccess;

export const getGetUserExchangeAccountsUrl = () => {
  return `/api/exchange-account/user-accounts`;
};

export const getUserExchangeAccounts = async (
  options?: RequestInit
): Promise<getUserExchangeAccountsResponse> => {
  return customFetch<getUserExchangeAccountsResponse>(
    getGetUserExchangeAccountsUrl(),
    {
      ...options,
      method: "GET",
    }
  );
};

export type getExchangeAccountsCountResponse200 = {
  data: number;
  status: 200;
};

export type getExchangeAccountsCountResponseSuccess =
  getExchangeAccountsCountResponse200 & {
    headers: Headers;
  };
export type getExchangeAccountsCountResponse =
  getExchangeAccountsCountResponseSuccess;

export const getGetExchangeAccountsCountUrl = () => {
  return `/api/exchange-account/total-count`;
};

export const getExchangeAccountsCount = async (
  options?: RequestInit
): Promise<getExchangeAccountsCountResponse> => {
  return customFetch<getExchangeAccountsCountResponse>(
    getGetExchangeAccountsCountUrl(),
    {
      ...options,
      method: "GET",
    }
  );
};

export type getExchangeAccountsCountByTypeResponse200 = {
  data: number;
  status: 200;
};

export type getExchangeAccountsCountByTypeResponseSuccess =
  getExchangeAccountsCountByTypeResponse200 & {
    headers: Headers;
  };
export type getExchangeAccountsCountByTypeResponse =
  getExchangeAccountsCountByTypeResponseSuccess;

export const getGetExchangeAccountsCountByTypeUrl = (
  params: GetExchangeAccountsCountByTypeParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/exchange-account/exchange-count?${stringifiedParams}`
    : `/api/exchange-account/exchange-count`;
};

export const getExchangeAccountsCountByType = async (
  params: GetExchangeAccountsCountByTypeParams,
  options?: RequestInit
): Promise<getExchangeAccountsCountByTypeResponse> => {
  return customFetch<getExchangeAccountsCountByTypeResponse>(
    getGetExchangeAccountsCountByTypeUrl(params),
    {
      ...options,
      method: "GET",
    }
  );
};

export type getAllEventsResponse200 = {
  data: PageEventDto;
  status: 200;
};

export type getAllEventsResponseSuccess = getAllEventsResponse200 & {
  headers: Headers;
};
export type getAllEventsResponse = getAllEventsResponseSuccess;

export const getGetAllEventsUrl = (params?: GetAllEventsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["status", "sort"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? "null" : v.toString());
      });
      return;
    }

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/events?${stringifiedParams}`
    : `/api/events`;
};

export const getAllEvents = async (
  params?: GetAllEventsParams,
  options?: RequestInit
): Promise<getAllEventsResponse> => {
  return customFetch<getAllEventsResponse>(getGetAllEventsUrl(params), {
    ...options,
    method: "GET",
  });
};

export type getFeaturedEventsResponse200 = {
  data: EventDto[];
  status: 200;
};

export type getFeaturedEventsResponseSuccess = getFeaturedEventsResponse200 & {
  headers: Headers;
};
export type getFeaturedEventsResponse = getFeaturedEventsResponseSuccess;

export const getGetFeaturedEventsUrl = (params?: GetFeaturedEventsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/events/featured?${stringifiedParams}`
    : `/api/events/featured`;
};

export const getFeaturedEvents = async (
  params?: GetFeaturedEventsParams,
  options?: RequestInit
): Promise<getFeaturedEventsResponse> => {
  return customFetch<getFeaturedEventsResponse>(
    getGetFeaturedEventsUrl(params),
    {
      ...options,
      method: "GET",
    }
  );
};

export type getActiveEventsResponse200 = {
  data: EventDto[];
  status: 200;
};

export type getActiveEventsResponseSuccess = getActiveEventsResponse200 & {
  headers: Headers;
};
export type getActiveEventsResponse = getActiveEventsResponseSuccess;

export const getGetActiveEventsUrl = (params?: GetActiveEventsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/events/active?${stringifiedParams}`
    : `/api/events/active`;
};

export const getActiveEvents = async (
  params?: GetActiveEventsParams,
  options?: RequestInit
): Promise<getActiveEventsResponse> => {
  return customFetch<getActiveEventsResponse>(getGetActiveEventsUrl(params), {
    ...options,
    method: "GET",
  });
};

export type getAllBenefitsResponse200 = {
  data: BenefitDto[];
  status: 200;
};

export type getAllBenefitsResponseSuccess = getAllBenefitsResponse200 & {
  headers: Headers;
};
export type getAllBenefitsResponse = getAllBenefitsResponseSuccess;

export const getGetAllBenefitsUrl = (params?: GetAllBenefitsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/benefits?${stringifiedParams}`
    : `/api/benefits`;
};

export const getAllBenefits = async (
  params?: GetAllBenefitsParams,
  options?: RequestInit
): Promise<getAllBenefitsResponse> => {
  return customFetch<getAllBenefitsResponse>(getGetAllBenefitsUrl(params), {
    ...options,
    method: "GET",
  });
};

export type getUserBenefitsResponse200 = {
  data: UserBenefitDto[];
  status: 200;
};

export type getUserBenefitsResponseSuccess = getUserBenefitsResponse200 & {
  headers: Headers;
};
export type getUserBenefitsResponse = getUserBenefitsResponseSuccess;

export const getGetUserBenefitsUrl = () => {
  return `/api/benefits/user`;
};

export const getUserBenefits = async (
  options?: RequestInit
): Promise<getUserBenefitsResponse> => {
  return customFetch<getUserBenefitsResponse>(getGetUserBenefitsUrl(), {
    ...options,
    method: "GET",
  });
};

export type getTotalBenefitEarningsResponse200 = {
  data: number;
  status: 200;
};

export type getTotalBenefitEarningsResponseSuccess =
  getTotalBenefitEarningsResponse200 & {
    headers: Headers;
  };
export type getTotalBenefitEarningsResponse =
  getTotalBenefitEarningsResponseSuccess;

export const getGetTotalBenefitEarningsUrl = () => {
  return `/api/benefits/total-benefit-earnings`;
};

export const getTotalBenefitEarnings = async (
  options?: RequestInit
): Promise<getTotalBenefitEarningsResponse> => {
  return customFetch<getTotalBenefitEarningsResponse>(
    getGetTotalBenefitEarningsUrl(),
    {
      ...options,
      method: "GET",
    }
  );
};

export type getAvailableBenefitsForUserResponse200 = {
  data: BenefitDto[];
  status: 200;
};

export type getAvailableBenefitsForUserResponseSuccess =
  getAvailableBenefitsForUserResponse200 & {
    headers: Headers;
  };
export type getAvailableBenefitsForUserResponse =
  getAvailableBenefitsForUserResponseSuccess;

export const getGetAvailableBenefitsForUserUrl = () => {
  return `/api/benefits/available`;
};

export const getAvailableBenefitsForUser = async (
  options?: RequestInit
): Promise<getAvailableBenefitsForUserResponse> => {
  return customFetch<getAvailableBenefitsForUserResponse>(
    getGetAvailableBenefitsForUserUrl(),
    {
      ...options,
      method: "GET",
    }
  );
};
